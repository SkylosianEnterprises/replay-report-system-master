{
  "name": "rabbit-node-lib",
  "description": "Manta rabbitmq node library",
  "main": "index.js",
  "author": {
    "name": "Manta Media"
  },
  "version": "0.1.7-5",
  "repository": {
    "type": "svn",
    "url": "http://github/SkylosianEnterprises/rabbit-node-lib"
  },
  "bugs": {
    "url": "http://trac/trac/main/query?col=id&col=summary&col=status&col=type&col=priority&col=milestone&col=component&keywords=~rabbit-node-lib&order=priority"
  },
  "licenses": [
    {
      "type": "MANTA",
      "url": "http://dogpawz.com/dont/steal/our/stuff"
    }
  ],
  "dependencies": {
    "amqp": "*",
    "async": "*",
    "q": "*",
    "json-schema": "*",
    "node-uuid": "*"
  },
  "devDependencies": {
    "jasmine-node": "*",
    "rrcf": "git+ssh://git@github.com:SkylosianEnterprises/rrcf.git",
    "common-lib": "git+ssh://git@github.com/SkylosianEnterprises/nodejs-common-lib.git",
    "mongoose": "*"
  },
  "scripts": {
    "update": "npm pack ; ls *.tgz | tail --lines=1 | xargs -iDDD cp DDD event-relay-latest.tgz",
    "test": "jasmine-node tests"
  },
  "publishConfig": {
    "registry": "http://localhost:8241"
  },
  "readme": "# rabbit-node-lib\r\n\r\nThis is an abstraction making it easy to communicate with our rabbitmq servers.\r\n\r\n## Installation\r\n\r\nnpm install rabbit-node-lib\r\n\r\n## Synopsis\r\n\r\nThe simplest possible interface to create and send a MantaEvent\r\n\r\n```javascript\r\n\r\nvar EventSystem = require('rabbit-node-lib');\r\nvar sender = new EventSystem.Emitter(\r\n\t{ exchange: \"MantaEventTransitional\"\r\n\t, routingKey: \"testing\"\r\n\t, rabbit: new EventSystem.Rabbit(\r\n\t\t{ connection: { url: \"amqp://localhost/\" }\r\n\t\t, exchanges: [ { \"name\": \"MantaEventTransitional\" , \"type\": \"topic\" } ]\r\n\t\t} )\r\n\t, schemaMgr: new EventSystem.SchemaMgr(\r\n\t\t{ \"schemaSchema\": \"/home/sbx/sbx.rabbitmq.current/schemata/JsonSchema.schema\"\r\n\t\t, \"schemaDirectories\": \"/home/sbx/sbx.rabbitmq.current/schemata\"\r\n\t\t} )\r\n\t} );\r\n\r\n// simple form, send eventType and payload as hash\r\nsender.envelope( \r\n\t{ eventType: 'QueryTimer'\r\n\t, payload: {md5: '...', milliseconds:123456 }\r\n\t, actor: { id: 'fido', type:'canine'} \r\n\t} ).emit();\r\n\r\n// also can specify payload separately.\r\nsender.envelope( \r\n\t{ payload: sender.schema_mgr.message( 'QueryTimer' , { md5: '...', milliseconds: 123456 } )\r\n\t, actor: { id: 'dog', type:'canine'}\r\n\t} ).emit();\r\n\r\n\r\n```\r\n\r\n## Synopsis\r\n\r\nThis uses the event based interface, allowing you to dynamically add queues and exchanges as needed \r\n\r\n```javascript\r\nvar Rabbit = require('rabbit-node-lib/lib/RabbitMQ');\r\n\r\n// basic operation\r\n// get a connection\r\nvar rabbit = new Rabbit( { connection: { options: { url: 'amqp://user@pass@localhost:5672/' } } } );\r\n\r\n// connected, declare exchange and queue\r\nrabbit.once('Rabbit_Ready', function (rabbit) {\r\n\trabbit.emit('Rabbit_Declare_Exchange', { name: 'MyEventExchange' } );\r\n\trabbit.emit('Rabbit_Declare_Queue', { name: 'MyQueueName' } );\r\n} );\r\n\r\n// queue is declared, bind to it\r\nrabbit.once('Rabbit_QueueReady', function (queue) {\r\n\trabbit.emit('Rabbit_Bind', queue, 'MyEventExchange', 'key' })\r\n} );\r\n\r\n// bind is ready, subscribe to it\r\nrabbit.once('Rabbit_BindReady', function (queue, exchange, key) {\r\n\trabbit.emit('Rabbit_Subscribe', queue);\r\n} );\r\n\r\n// subscribe is ready, AND the queue is subscribed to, send a message on the exchange!\r\n// this probably works in either order\r\nrabbit.once(\"Rabbit_ExchangeReady\", function (exchange) {\r\n\trabbit.once('Rabbit_Subscribed', function (queue) {\r\n\t\trabbit.emit('MyEventExchange', 'key', {a:\"This is a message\"});\r\n\t} );\r\n} );\r\n\r\n// Receive a message on the queue, on an event named for the name of the queue\r\nrabbit.on('MyQueueName', function (message, headers, deliveryInfo) {\r\n\tconsole.log(deliveryInfo.routingKey + '> ' + message.a);\r\n\r\n\t// rabbit.allDone() // automatic cleanup\r\n\t// lets manually clean ourselves up just for demonstration\r\n\t// Unbind the binding\r\n\trabbit.emit(\"Rabbit_Unbind\", 'MyQueueName', 'key');\r\n\t// could also rabbit.emit('Rabbit_UnbindAll');\r\n\t// once its unbound, unsubscribe\r\n\trabbit.once(\"Rabbit_Unbound\", function(queue) {\r\n\t\trabbit.emit(\"Rabbit_Unsubscribe\", 'MyQueueName');\r\n\t\t// once its unsubscribed, destroy the queue and exchange\r\n\t\trabbit.once(\"Rabbit_Unsubscribed\", function(queue) {\r\n\t\t\trabbit.emit(\"Rabbit_Destroy_Queue\", queue);\r\n\t\t\trabbit.emit(\"Rabbit_Destroy_Exchange\", 'MyEventExchange', true); // 'ifUnused'\r\n\t\t\trabbit.once(\"Rabbit_Queue_Destroyed\", function(queue) {\r\n\t\t\t\tconsole.log(\"queue gone\");\r\n\t\t\t} );\r\n\t\t\trabbit.once(\"Rabbit_Exchange_Destroyed\", function(queue) {\r\n\t\t\t\tconsole.log(\"exchange gone\");\r\n\t\t\t\trabbit.emit('disconnect');\r\n\t\t\t} );\r\n\t\t} );\r\n\t} );\r\n} );\r\n\r\n```\r\n\r\nwould output:\r\n\r\nkey> This is a message\r\n\r\nThe supplied deliveryInfo looks like this:\r\n\r\n```javascript\r\n{ contentType: 'application/json'\r\n, queue: 'MyQueueName'\r\n, deliveryTag: 1\r\n, redelivered: false\r\n, exchange: 'MyEventExchange'\r\n, routingKey: 'key'\r\n, consumerTag: 'node-amqp-30383-0.9582679294981062' \r\n}\r\n```\r\n\r\n## Details\r\n\r\nExample with every possible option enumerated\r\n\r\n```javascript\r\n\r\nvar rabbit = new Rabbit(\r\n\t{ connection:\r\n\t\t{ options: \r\n\t\t\t{ url: 'amqp://user@pass@localhost:5672/' // OR the below options\r\n\t\t\t, host: 'localhost'\r\n\t\t\t, port: 5672\r\n\t\t\t, login: 'user'\r\n\t\t\t, password: 'pass'\r\n\t\t\t, vhost: '/'\r\n\t\t\t}\r\n\t\t, implOptions: \r\n\t\t\t{ defaultExchangeName: 'myDefault'\r\n\t\t\t, routingKeyInPayload: false\r\n\t\t\t, deliveryTagInPayload: false\r\n\t\t\t, reconnect: true\r\n\t\t\t, reconnectBackoffStrategy: ['linear','exponential'][0]\r\n\t\t\t, reconnectExponentialLimit: 120000 // ms\r\n\t\t\t, reconnectBackoffTime: 1000 // ms\r\n\t\t\t}\r\n\t\t}\r\n\t, exchanges:\r\n\t\t[ { name: 'MyEventExchange'\r\n\t\t\t, type: ['direct','fanout','topic'][2]\r\n\t\t\t, passive: false\r\n\t\t\t, durable: false\r\n\t\t\t, autoDelete: false\r\n\t\t\t, confirm: false // ack|error event on publish OR callback called\r\n\t\t\t}\r\n\t\t]\r\n\t, queues:\r\n\t\t[ { name: 'MyQueueName'\r\n\t\t\t, bindings:\r\n\t\t\t\t[ { routing_key: 'ARoutingKey'\r\n\t\t\t\t\t, exchange: 'AnExchange'\r\n\t\t\t\t\t}\r\n\t\t\t\t, { routing_key: 'AnotherKey'\r\n\t\t\t\t\t, exchange: 'AnExchange'\r\n\t\t\t\t\t}\r\n\t\t\t\t, { routing_key: 'AnotherKey'\r\n\t\t\t\t\t, exchange: 'OtherExchange'\r\n\t\t\t\t\t}\r\n\t\t\t\t]\r\n\t\t\t, passive: false\r\n\t\t\t, durable: false\r\n\t\t\t, exclusive: false\r\n\t\t\t, autoDelete: true\r\n\t\t\t, noDeclare: false\r\n\t\t\t, arguments: { } // additional arguments for create?\r\n\t\t\t, closeChannelOnUnsubscribe: false\r\n\t\t\t, subscribeOptions:\r\n\t\t\t\t{ ack: false // as fast as they come in \r\n\t\t\t\t\t\t\t\t\t\t// - call queue.shift in listenCallback to enable \r\n\t\t\t\t\t\t\t\t\t\t// next delivery if true\r\n\t\t\t\t, prefetchCount: 1 // how many to get before an ack is sent (0 unlimited)\r\n\t\t\t\t, \r\n\t\t\t\t}\r\n\t\t\t, listenCallback: \r\n\t\t\t\tfunction (message, headers, deliveryInfo, queue, rabbit) { \r\n\t\t\t\t\t// message - the message received\r\n\t\t\t\t\t// headers - hash of the headers of the message\r\n\t\t\t\t\t// deliveryInfo - hash of delivery information indicated above\r\n\t\t\t\t\t// queue - the queue object - use for .shift() in ack:true mode\r\n\t\t\t\t\t// rabbit - our object, in case you want to emit on it\r\n\t\t\t\t\t// Do something with the received messages here\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t]\r\n\t} , function (error, rabbit) {\r\n\t\t\trabbit.emit \r\n\t\t\t\t( 'MyEventExchange'\r\n\t\t\t\t, \"myRoutingKey\"\r\n\t\t\t\t, { message: \"here\" }\r\n\t\t\t\t, { mandatory: false\r\n\t\t\t\t\t, immediate: false\r\n\t\t\t\t\t, contentType: 'application/octet-stream'\r\n\t\t\t\t\t, contentEncoding: null\r\n\t\t\t\t\t, headers: { header: \"value\" }\r\n\t\t\t\t\t, deliveryMode: {nonpersistant:1,persistant:2}.nonpersistant\r\n\t\t\t\t\t, priority: 5 // 0-9\r\n\t\t\t\t\t, replyTo: 'myReplyQueue'\r\n\t\t\t\t\t}\r\n\t\t\t\t, function (booleanError) {\r\n\t\t  \t\t\t// called when exchange in confirm mode\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t} );\r\n\r\n```\r\n",
  "readmeFilename": "README.md",
  "_id": "rabbit-node-lib@0.1.7-5",
  "dist": {
    "shasum": "ca4e54291fda9e7040aa2a6ede2fd8108ef4ca34"
  },
  "_resolved": "git+ssh://git@github.com/SkylosianEnterprises/rabbit-node-lib.git#35e975f7502a602b0e311476e898b8a7c3acd83d",
  "_from": "rabbit-node-lib@git+ssh://git@github.com/SkylosianEnterprises/rabbit-node-lib.git"
}
